#!/bin/bash

# Copyright (c) 2010, Lawrence Livermore National Security, LLC. Produced at the
# Lawrence Livermore National Laboratory. LLNL-CODE-443211. All Rights reserved.
# See file COPYRIGHT for details.
#
# This file is part of the MFEM library. For more information and source code
# availability see http://mfem.org.
#
# MFEM is free software; you can redistribute it and/or modify it under the
# terms of the GNU Lesser General Public License (as published by the Free
# Software Foundation) version 2.1 dated February 1999.

# Print usage information
case $1 in
   -h|-help)
      cat <<EOF

   $0 [-h|-help] {mfem_dir}

   where: {mfem_dir}  is the MFEM source directory [default value: ../..]
          -h|-help    prints this usage information and exits

   This script checks if the current branch history, defined as the commits that
   will be merged in master (those shown in a GitHub PR), contains unusually
   large files, unusually large number of changes in a commit, unusually large
   number of commits, etc.

   The specific checks are provided at 3 levels: branch, commit and file.

   Branch-level checks:
   - Check if the branch contains unusually large number of commits

   Commit-level checks:
   - Check if the commit changes an unusually large number of files
   - Check if the commit changes an unusually large number of lines

   File-level checks:
   - Check if the file is binary
   - Check if the file is unusually large
   - Check if an unusually large number of lines have been added to the file
   - Check if an unusually large number of lines have been deleted from the file

   To be useful, the script should be run in a repository that is not in a
   "detached HEAD" state.

   Example usage: $0 ../..

EOF
      exit
      ;;
esac

# Setup
cur_dir=`pwd`
mfem_dir=$1
if [ "$mfem_dir" = "" ]; then
    mfem_dir="../.."
fi
cd $mfem_dir
mfem_dir=`pwd`
shift

# Maximum number of acceptable commits in the branch
branch_max_commits=0
# Maximum number of acceptable files changed in any commit in the branch
commit_max_files_changed=0
# Maximum number of acceptable lines changed in any commit in the branch
commit_max_lines_changed=0
# Maximum acceptable size (in K) of any file changed in any commit in the branch
file_max_size=0
# Maximum number of acceptable lines added to any file changed in any commit in the branch
file_max_lines_added=0
# Maximum number of acceptable lines deleted from any file changed in any commit in the branch
file_max_lines_deleted=0

current_branch="$(git symbolic-ref --short HEAD)"
echo "--> current_branch = '${current_branch}'" 1>&2

# Check if the branch contains unusually large number of commits
num_commits="$(git rev-list --count master..${current_branch})"
echo "--> num_commits = '$num_commits}'" 1>&2
if [ ${num_commits} -gt ${branch_max_commits} ]
then
    printf '\033[35m'"This branch contains unusually many commits: " 1>&2
    printf "${num_commits} commits not in master"'\033[0m\n' 1>&2
fi

# Check all the commits in the current branch (i.e. the commits that will be
# merged in master, as shown in a GitHub PR):
while read -r rev; do
    echo "Processing commit ${rev}..." 1>&2
    shortrev="$(git log -1 --format=%h ${rev})" # short commit hash

    # Check if the commit changes an unusually large number of files
    files_changed="$(git show --pretty="" --shortstat ${rev} | awk '{print $1}')"
    echo "--> git show --pretty="" --shortstat = '$(git show --pretty="" --shortstat ${rev})'" 1>&2
    echo "--> files_changed = '${files_changed}'" 1>&2
    if [ ${files_changed} -gt ${commit_max_files_changed} ]
    then
        printf '\033[36m'"Commit ${shortrev} changes unusually many files: " 1>&2
        printf "${files_changed} files changed"'\033[0m\n' 1>&2
    fi

    # Check if the commit changes an unusually large number of lines
    lines_changed="$(git show --pretty="" --shortstat ${rev} | awk '{print $4+$6}')"
    echo "--> lines_changed = '${lines_changed}'" 1>&2
    if [ ${lines_changed} -gt ${commit_max_lines_changed} ]
    then
        printf '\033[36m'"Commit ${shortrev} makes unusually many changes: " 1>&2
        printf "${lines_changed} total lines changed"'\033[0m\n' 1>&2
    fi

    # Check all the files modified in the current commit:
    for filelog in "$(git show --pretty="" --numstat ${rev})"
    do
	echo "--> git show --pretty="" --numstat = '$(git show --pretty="" --numstat ${rev})'" 1>&2
        fname="$(echo ${filelog} | awk '{print $3}')"
	echo "--> fname = '${fname}'" 1>&2
        if [ -e $fname ] # exclude deleted files
        then
            # Check if the file is binary (non-text file as reported by "file")
            binary="$(file -b ${fname} | grep -v 'text')"
	    echo "--> file -b = '$(file -b ${fname})'" 1>&2
	    echo "--> binary = '${binary}'" 1>&2
            if [ -n "${binary}" ]
            then
                printf '\033[31m'"Commit ${shortrev} contains a binary file: " 1>&2
                printf "${fname} (${binary})"'\033[0m\n' 1>&2
            fi

            # Check if the file is unusually large
            file_size="$(du -k ${fname} | cut -f1)"
	    echo "--> du -k = '$(du -k ${fname})'" 1>&2
	    echo "--> file_size = '${file_size}'" 1>&2
            if [ ${file_size} -gt ${file_max_size} ]
            then
                printf '\033[31m'"Commit ${shortrev} adds/modifies a large file: " 1>&2
                printf "${fname} (size ${file_size}K)"'\033[0m\n' 1>&2
            fi

            # Check if an unusually large number of lines have been added to the file
            file_lines_added="$(echo ${filelog} | awk '{print $1}')"
	    echo "--> file_lines_added = '${file_lines_added}'" 1>&2
            if [ ${file_lines_added} -gt ${file_max_lines_added} ]
            then
                printf '\033[31m'"Commit ${shortrev} adds unusually many lines to " 1>&2
                printf "${fname} (${file_lines_added} lines added)"'\033[0m\n' 1>&2
            fi

            # Check if an unusually large number of lines have been deleted from the file
            file_lines_deleted="$(echo ${filelog} | awk '{print $2}')"
	    echo "--> file_lines_deleted = '${file_lines_deleted}'" 1>&2
            if [ ${file_lines_deleted} -gt ${file_max_lines_deleted} ]
            then
                printf '\033[31m'"Commit ${shortrev} deletes unusually many lines from " 1>&2
                printf "${fname} (${file_lines_deleted} lines deleted)"'\033[0m\n' 1>&2
            fi
        fi
    done
done < <(git rev-list --reverse --no-merges master..${current_branch})

# Return to the original branch and directory
cd $cur_dir
